/**
 * 手写节流函数 (Throttle)
 * 
 * 题目描述：
 * 实现一个节流函数，在指定的时间间隔内，无论触发多少次事件，
 * 函数只会执行一次。节流常用于优化高频触发的事件，如滚动、鼠标移动等。
 * 
 * 节流 vs 防抖的区别：
 * - 节流：控制函数执行频率，每隔一段时间执行一次
 * - 防抖：延迟函数执行，只有在停止触发后才执行
 * 
 * 应用场景：
 * 1. 滚动事件监听（scroll）
 * 2. 鼠标移动事件（mousemove）
 * 3. 窗口大小调整（resize）
 * 4. 按钮点击防止重复提交
 * 
 * 实现方式：
 * 1. 时间戳方式：记录上次执行时间，比较时间差
 * 2. 定时器方式：使用 setTimeout 控制执行
 *
 * ---------------------------------------------------------------------------
 * 节流的好处：
 * 1. 控制执行频率：无论触发多快，在时间间隔内只执行一次，避免“暴击”
 * 2. 保证持续反馈：滚动、拖拽过程中会按固定间隔执行，用户能持续看到更新
 * 3. 减轻性能压力：scroll、mousemove 等高频事件被限流，CPU/渲染更稳定
 * 4. 兼顾体验与性能：既不过度执行，又不至于长时间无响应
 *
 * 不节流会有什么问题：
 * 1. 滚动监听：scroll 一帧可触发很多次 → 回调执行次数极多，页面卡顿、掉帧
 * 2. mousemove：鼠标移动时每秒可触发数十上百次 → 复杂逻辑或 DOM 操作导致卡顿
 * 3. resize：拖拽窗口时连续触发 → 布局、图表重算过于频繁，界面卡死感
 * 4. 进度/位置更新：若每次事件都更新 UI → 重绘过多，动画不流畅
 *
 * 为什么会有这些问题：
 * 高频事件在短时间内产生大量调用，主线程被占满，导致：
 * - 渲染帧无法按时完成（掉帧、卡顿）
 * - 若回调里还有请求或重计算，会雪上加霜
 * 节流把“执行次数”限制在“时间维度”上，使单位时间内最多执行 N 次，从而可控。
 *
 * 节流时间如何衡量：
 * 1. 按人眼/交互感知：一般 16ms 一帧（60fps），间隔常取 100～200ms 已足够流畅
 * 2. 按业务需求：进度条、位置更新可用 100ms；统计类（如曝光）可用 200～500ms
 * 3. 按性能预算：间隔越小执行越频繁，要在“流畅度”和“CPU 占用”之间折中
 * 4. 经验值参考：scroll 100～200ms，mousemove 50～100ms，resize 100～250ms
 */

// 方式一：时间戳实现（立即执行版本）
function throttled1(fn, delay = 500) {
  let oldtime = Date.now(); // 上次执行时间
  return function () {
    const args = arguments
    let newtime = Date.now(); // 当前时间
    if (newtime - oldtime >= delay) {
      fn(args)
      oldtime = Date.now(); // 更新上次执行时间
    }
  };
}

// 方式二：定时器实现（延迟执行版本）
function throttle2(fn, delay = 500) {
  let timer = null; // 定时器标识
  
  return function (...args) {
    const context = this;
    
    // 如果定时器不存在，则设置定时器
    if (!timer) {
      timer = setTimeout(() => {
        fn.apply(context, args);
        timer = null; // 执行完毕后清空定时器
      }, delay);
    }
  };
}
