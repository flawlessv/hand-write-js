/**
 * LeetCode 53. 最大子数组和（最大子序和）
 * LeetCode: https://leetcode.cn/problems/maximum-subarray/
 * 
 * 题目描述：
 * 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
 * 子数组 是数组中的一个连续部分。
 * 
 * 示例 1：
 * 输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
 * 输出：6
 * 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
 * 
 * 示例 2：
 * 输入：nums = [1]
 * 输出：1
 * 
 * 示例 3：
 * 输入：nums = [5,4,-1,7,8]
 * 输出：23
 * 
 * 解题思路（贪心算法）：
 * 核心思想：当前面子数组和为负数时，丢弃前面的子数组，从当前位置重新开始
 * 
 * 贪心策略详解：
 * 1. 遍历数组，累加当前元素到当前子数组和 curSum
 * 2. 如果 curSum > maxSum，更新全局最大和 maxSum
 * 3. 如果 curSum < 0，说明当前子数组和为负数，继续累加只会让后面的和更小
 *    因此丢弃当前子数组，将 curSum 重置为 0，从下一个位置重新开始
 * 4. 这样保证每一步都做出局部最优选择（丢弃负数和，保留正数和）
 * 
 * 为什么可以丢弃负数和？
 * - 如果当前子数组和为负数，加上后面的任何数，都不会比直接从后面开始更好
 * - 例如：[-2, 1, -3, 4]，当累加到 -3 时，和为 -4（负数）
 *   此时丢弃前面的 [-2, 1, -3]，直接从 4 开始，结果会更好
 * 
 * 时间复杂度：O(n)，只需遍历一次数组
 * 空间复杂度：O(1)，只使用了常数额外空间
 */

/**
 * 贪心算法实现最大子数组和
 * @param {number[]} nums - 整数数组
 * @return {number} - 最大子数组和
 */
var maxSubArray = function(nums) {
    // maxSum：全局最大和，初始化为负无穷，确保能处理全负数数组
    let maxSum = -Infinity;
    // curSum：当前子数组的和，初始化为0
    let curSum = 0;
    
    // 遍历数组
    for(let i = 0; i < nums.length; i++) {
        // 累加当前元素到当前子数组和
        curSum += nums[i];
        
        // 更新全局最大和
        // 贪心：每一步都检查当前和是否更大
        maxSum = Math.max(curSum, maxSum);
        
        // 贪心策略：如果当前和为负数，丢弃前面的子数组
        // 因为负数加上任何数都不会比直接从下一个数开始更好
        if(curSum < 0) {
            curSum = 0;  // 重置当前和，从下一个位置重新开始
        }
    }
    
    return maxSum;
};




