/**
 * LeetCode 455. 分发饼干
 * LeetCode: https://leetcode.cn/problems/assign-cookies/
 * 
 * 题目描述：
 * 假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。
 * 对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；
 * 并且每块饼干 j，都有一个尺寸 s[j]。
 * 如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i，这个孩子会得到满足。
 * 你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。
 * 
 * 示例 1：
 * 输入：g = [1,2,3], s = [1,1]
 * 输出：1
 * 解释：你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
 *      虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
 *      所以你应该输出1。
 * 
 * 示例 2：
 * 输入：g = [1,2], s = [1,2,3]
 * 输出：2
 * 解释：你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。
 *      你拥有的饼干数量和尺寸都足以让所有孩子满足。
 *      所以你应该输出2。
 * 
 * 解题思路（贪心算法）：
 * 核心思想：优先满足胃口小的孩子，使用最小的能满足该孩子的饼干
 * 
 * 贪心策略详解：
 * 1. 将孩子的胃口值 g 和饼干尺寸 s 都按升序排序
 * 2. 使用双指针 i（指向孩子）和 j（指向饼干）
 * 3. 对于每块饼干，尝试分配给当前最小的未满足的孩子：
 *    - 如果当前饼干能满足当前孩子（s[j] >= g[i]），则分配，两个指针都后移
 *    - 如果当前饼干不能满足当前孩子（s[j] < g[i]），则这块饼干太小，只能尝试下一个更大的饼干
 * 4. 贪心策略：优先用最小的饼干满足胃口最小的孩子，这样可以最大化满足的孩子数量
 * 
 * 为什么这样贪心是正确的？
 * - 如果当前最小的饼干能满足当前胃口最小的孩子，那么用这块饼干满足这个孩子是最优的
 * - 因为如果不用这块饼干，这块饼干可能只能满足胃口更大的孩子，而胃口小的孩子可能无法被满足
 * - 例如：g=[1,2], s=[1,2,3]
 *   用 s[0]=1 满足 g[0]=1，用 s[1]=2 满足 g[1]=2，可以满足2个孩子
 *   如果用 s[0]=1 去满足 g[1]=2（无法满足），结果只能满足1个孩子
 * 
 * 时间复杂度：O(n log n + m log m)，其中 n 是孩子数量，m 是饼干数量（排序的时间复杂度）
 * 空间复杂度：O(1)，只使用了常数额外空间（排序可能使用 O(log n) 的栈空间）
 */

/**
 * 贪心算法实现分发饼干
 * @param {number[]} g - 孩子的胃口值数组
 * @param {number[]} s - 饼干的尺寸数组
 * @return {number} - 能够满足的孩子数量
 */
var findContentChildren = function(g, s) {
    // res：记录能够满足的孩子数量
    let res = 0;
    
    // 贪心策略：优先满足胃口小的孩子，使用最小的能满足的饼干
    // 因此需要将两个数组都排序
    g.sort((a, b) => a - b);  // 将孩子胃口值按升序排序
    s.sort((a, b) => a - b);  // 将饼干尺寸按升序排序
    
    // 双指针：i 指向当前要满足的孩子，j 指向当前可用的饼干
    let i = 0;  // 孩子指针
    let j = 0;  // 饼干指针
    
    // 遍历所有饼干
    while(j < s.length) {
        // 如果当前饼干能满足当前孩子的胃口
        if(g[i] <= s[j]) {
            // 分配饼干给孩子，满足的孩子数量加1
            res++;
            // 孩子指针后移，处理下一个孩子
            i++;
        }
        // 无论是否分配成功，饼干指针都要后移
        // 如果分配成功：这块饼干已使用，尝试下一块
        // 如果分配失败：这块饼干太小，尝试更大的饼干
        j++;
    }
    
    return res;
};
