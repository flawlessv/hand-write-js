/**
 * LeetCode 376. 摆动序列
 * LeetCode: https://leetcode.cn/problems/wiggle-subsequence/
 * 
 * 题目描述：
 * 如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列。
 * 第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。
 * 
 * 例如，[1, 7, 4, 9, 2, 5] 是一个 摆动序列，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。
 * 相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，
 * 第二个序列是因为它的最后一个差值为零。
 * 
 * 子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。
 * 给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度。
 * 
 * 示例 1：
 * 输入：nums = [1,7,4,9,2,5]
 * 输出：6
 * 解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。
 * 
 * 示例 2：
 * 输入：nums = [1,17,5,10,13,15,10,5,16,8]
 * 输出：7
 * 解释：这个序列包含几个长度为 7 摆动序列。
 *      其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。
 * 
 * 示例 3：
 * 输入：nums = [1,2,3,4,5,6,7,8,9]
 * 输出：2
 * 
 * 解题思路（贪心算法）：
 * 核心思想：统计峰和谷的数量，即统计差值的正负交替出现的次数
 * 
 * 贪心策略详解：
 * 1. 摆动序列的本质是：相邻元素的差值在正数和负数之间交替出现
 * 2. 我们只需要统计有多少个"峰"和"谷"（即差值的正负交替点）
 * 3. 使用两个变量：
 *    - curDiff：当前相邻两个元素的差值（nums[i+1] - nums[i]）
 *    - preDiff：上一次有效的差值（上一次摆动时的差值，即上一次峰或谷的差值）
 * 4. 判断是否形成摆动：
 *    - 如果 curDiff > 0 且 preDiff <= 0：从下降或平缓转为上升，形成谷
 *    - 如果 curDiff < 0 且 preDiff >= 0：从上升或平缓转为下降，形成峰
 * 5. 贪心策略：只要出现峰或谷，就计入结果，这样可以最大化摆动序列的长度
 * 
 * curDiff 和 preDiff 的含义详解：
 * - curDiff：当前差值，表示 nums[i+1] - nums[i]
 *   - curDiff > 0：当前趋势是上升
 *   - curDiff < 0：当前趋势是下降
 *   - curDiff = 0：当前是平缓（不形成摆动）
 * 
 * - preDiff：上一次有效的差值，即上一次形成摆动时的差值
 *   - preDiff > 0：上一次摆动是上升趋势（形成了峰）
 *   - preDiff < 0：上一次摆动是下降趋势（形成了谷）
 *   - preDiff = 0：初始状态或上一次没有形成摆动（平缓）
 * 
 * 判断逻辑：
 * - (curDiff > 0 && preDiff <= 0)：当前上升，且上一次是下降或平缓 → 形成谷转峰
 * - (curDiff < 0 && preDiff >= 0)：当前下降，且上一次是上升或平缓 → 形成峰转谷
 * 
 * 为什么 preDiff 初始化为 0？
 * - 这样可以处理第一个有效差值（无论是正还是负）都能被计入
 * - 例如：[1, 7, 4]，第一个差值 6 > 0，preDiff = 0 <= 0，满足条件，计入结果
 * 
 * 时间复杂度：O(n)，只需遍历一次数组
 * 空间复杂度：O(1)，只使用了常数额外空间
 */

/**
 * 贪心算法实现摆动序列
 * @param {number[]} nums - 整数数组
 * @return {number} - 最长摆动子序列的长度
 */
var wiggleMaxLength = function(nums) {
    // 边界条件：数组长度小于等于1，直接返回长度
    if(nums.length <= 1) return nums.length;
    
    // result：摆动序列的长度，初始化为1（至少包含第一个元素）
    let result = 1;
    
    // preDiff：上一次有效的差值（上一次摆动时的差值）
    // 初始化为0，这样可以处理第一个有效差值
    let preDiff = 0;
    
    // curDiff：当前相邻两个元素的差值
    let curDiff = 0;
    
    // 遍历数组，计算相邻元素的差值
    for(let i = 0; i < nums.length - 1; i++) {
        // 计算当前相邻两个元素的差值
        curDiff = nums[i + 1] - nums[i];
        
        // 判断是否形成摆动（峰或谷）
        // 条件1：curDiff > 0 && preDiff <= 0
        //   - 当前趋势上升，且上一次是下降或平缓 → 形成谷转峰
        // 条件2：curDiff < 0 && preDiff >= 0
        //   - 当前趋势下降，且上一次是上升或平缓 → 形成峰转谷
        // 注意：curDiff = 0 的情况不满足任何条件，不会计入结果（平缓不算摆动）
        if((curDiff > 0 && preDiff <= 0) || (curDiff < 0 && preDiff >= 0)) {
            // 找到一个新的峰或谷，摆动序列长度加1
            result++;
            // 更新 preDiff 为当前的 curDiff，记录这次摆动
            // 这样下次判断时，preDiff 就是上一次有效的差值
            preDiff = curDiff;
        }
        // 如果 curDiff = 0，不更新 preDiff，保持上一次的有效差值
    }
    
    return result;
};
